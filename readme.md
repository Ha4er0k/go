# Порівняння жадібного алгоритму та динамічного програмування

# Жадібний алгоритм (find_coins_greedy)

- Працює надзвичайно швидко — практично миттєво, навіть для великих сум.
- Добре підходить для класичних валютних систем, таких як євро чи долар, де номінали підібрані логічно (наприклад, [50, 25, 10, 5, 2, 1]).
- Завжди віддає перевагу найбільшим доступним монетам, що в більшості випадків дає хороший результат.
- Недолік: не гарантує мінімальної кількості монет, особливо якщо номінали мають «непередбачувану» структуру. Наприклад, для набору [9, 6, 1] може дати неефективне рішення.

# Алгоритм динамічного програмування (find_min_coins)

- Завжди знаходить оптимальне рішення з найменшою кількістю монет, незалежно від структури номіналів.
- Працює трохи повільніше, ніж жадібний, але все одно дуже швидко (соті частки секунди при нормальних обсягах).
- Підходить для будь-яких ситуацій, особливо якщо потрібно забезпечити точність і мінімізацію кількості монет.
- Універсальний: може працювати з будь-якою системою монет, у тому числі динамічно змінною.

# Коли який алгоритм використовувати?

#  Використовуйте жадібний алгоритм, якщо:
  - Система монет фіксована та логічно побудована.
  - Потрібна максимальна швидкість обчислення.
  - Можна допустити неідеальну кількість монет у деяких рідкісних випадках.

#  Використовуйте динамічне програмування, якщо:
  - Система монет нестандартна або змінюється.
  - Важливо мінімізувати кількість монет.
  - Потрібна точність і надійність незалежно від вхідних даних.
